// Nu Game Engine.
// Copyright (C) Bryan Edds, 2013-2020.

//*********************************************************************************************//
//                                                                                             //
// NOTE: This code is GENERATED by 'GenerateWorldBindings.fsx'! Do NOT edit this code by hand! //
//                                                                                             //
//*********************************************************************************************//

namespace Nu
open System
open System.Numerics
open Prime
open Nu

[<RequireQualifiedAccess>]
module WorldBindings =

    let [<Literal>] BindingKeywords =
        "v2 v4 v2i v4i color get getAsStream set setAsStream update streamEvent stream bind self parent grandparent game toData monitor " +
        "resolve relate tryGetIsSelectedScreenIdling tryGetIsSelectedScreenTransitioning isSelectedScreenIdling " +
        "isSelectedScreenTransitioning selectScreenOpt selectScreen tryTransitionScreen transitionScreen " +
        "setScreenSplash createDissolveScreenFromGroupFile6 createDissolveScreenFromGroupFile createSplashScreen6 createSplashScreen " +
        "reloadExistingAssets tryReloadAssets getCurrentSongOpt getCurrentSongPosition " +
        "getMasterAudioVolume getMasterSoundVolume getMasterSongVolume setMasterAudioVolume " +
        "setMasterSoundVolume setMasterSongVolume playSong playSong6 " +
        "playSound playSound3 fadeOutSong stopSong " +
        "hintAudioPackageUse hintAudioPackageDisuse reloadAudioAssets hintRenderPackageUse " +
        "hintRenderPackageDisuse reloadRenderAssets bodyExists getBodyContactNormals " +
        "getBodyLinearVelocity getBodyToGroundContactNormals getBodyToGroundContactNormalOpt getBodyToGroundContactTangentOpt " +
        "isBodyOnGround createBody createBodies destroyBody " +
        "destroyBodies createJoint createJoints destroyJoint " +
        "destroyJoints setBodyEnabled setBodyPosition setBodyRotation " +
        "setBodyLinearVelocity applyBodyLinearImpulse setBodyAngularVelocity applyBodyAngularImpulse " +
        "applyBodyForce localizeBodyShape isMouseButtonDown getMousePosition " +
        "isKeyboardKeyDown expandContent destroyImmediate destroy " +
        "tryGetParent getParent tryGetGrandparent getGrandparent " +
        "getChildren getExists getEntities0 getGroups0 " +
        "isSelected writeGameToFile readGameFromFile getScreens " +
        "setScreenDissolve destroyScreen createScreen createDissolveScreen " +
        "writeScreenToFile readScreenFromFile getGroups createGroup " +
        "destroyGroup destroyGroups writeGroupToFile readGroupFromFile " +
        "tryPickEntity writeEntityToFile getEntities destroyEntity " +
        "destroyEntities createEntity readEntityFromFile reassignEntity " +
        "trySetEntityOverlayNameOpt trySetEntityFacetNames getEyeCenter setEyeCenter " +
        "getEyeSize getEyeMargin setEyeSize getEyeBounds " +
        "getOmniScreenOpt setOmniScreenOpt getOmniScreen setOmniScreen " +
        "getSelectedScreenOpt constrainEyeBounds setSelectedScreenOpt getSelectedScreen " +
        "setSelectedScreen getViewBoundsRelative getViewBoundsAbsolute getViewBounds " +
        "isBoundsInView mouseToScreen mouseToWorld mouseToEntity " +
        "initPropertyAttributes getImperative getStandAlone getCollectionConfig " +
        "getLiveness getTickRate getTickRateF setTickRate " +
        "resetTickTime incTickTime decTickTime getTickTime " +
        "isTicking getClockDelta exit tryGetTextureSize " +
        "getTextureSize tryGetTextureSizeF getTextureSizeF reloadSymbols"

    let resolve relation world =
        let oldWorld = world
        try
            let relation =
                match ScriptingSystem.tryExport typeof<Relation<Object>> relation world with
                | Some value -> value :?> Relation<Object>
                | None -> failwith "Invalid argument type for 'relation'; expecting a value convertable to Relation`1."
            let result = World.resolveGeneralized relation world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Address<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let relate address world =
        let oldWorld = world
        try
            let struct (address, world) =
                let context = World.getScriptContext world
                match World.evalInternal address world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Address must be either a String or Keyword."
            let result = World.relateGeneralized address world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Relation<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'relate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let selectScreenOpt screenOpt world =
        let oldWorld = world
        try
            let screenOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> screenOpt world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'screenOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.selectScreenOpt screenOpt world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let selectScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.selectScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryTransitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryTransitionScreen destination world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryTransitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let transitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.transitionScreen destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'transitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setScreenSplash splashDataOpt destination screen world =
        let oldWorld = world
        try
            let splashDataOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SplashDescriptor>> splashDataOpt world with
                | Some value -> value :?> FSharpOption<SplashDescriptor>
                | None -> failwith "Invalid argument type for 'splashDataOpt'; expecting a value convertable to FSharpOption`1."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenSplash splashDataOpt destination screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenSplash' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<String> groupFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<String> songOpt world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to String."
            let groupFilePath =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> groupFilePath world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'groupFilePath'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromGroupFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashDescriptor =
                match ScriptingSystem.tryExport typeof<SplashDescriptor> splashDescriptor world with
                | Some value -> value :?> SplashDescriptor
                | None -> failwith "Invalid argument type for 'splashDescriptor'; expecting a value convertable to SplashDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen nameOpt splashDescriptor destination world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashDescriptor =
                match ScriptingSystem.tryExport typeof<SplashDescriptor> splashDescriptor world with
                | Some value -> value :?> SplashDescriptor
                | None -> failwith "Invalid argument type for 'splashDescriptor'; expecting a value convertable to SplashDescriptor."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen nameOpt splashDescriptor destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadExistingAssets world =
        let oldWorld = world
        try
            let result = World.reloadExistingAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadExistingAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryReloadAssets world =
        let oldWorld = world
        try
            let result = World.tryReloadAssets world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryReloadAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCurrentSongOpt world =
        let oldWorld = world
        try
            let result = World.getCurrentSongOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<SongDescriptor>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCurrentSongPosition world =
        let oldWorld = world
        try
            let result = World.getCurrentSongPosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Double> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCurrentSongPosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterAudioVolume world =
        let oldWorld = world
        try
            let result = World.getMasterAudioVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterAudioVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterSoundVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSoundVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSoundVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMasterSongVolume world =
        let oldWorld = world
        try
            let result = World.getMasterSongVolume world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMasterSongVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterAudioVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterAudioVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterAudioVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterSoundVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSoundVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSoundVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setMasterSongVolume volume world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let result = World.setMasterSongVolume volume world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setMasterSongVolume' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world =
        let oldWorld = world
        try
            let timeToFadeInSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeInSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeInSongMs'; expecting a value convertable to Int32."
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let start =
                match ScriptingSystem.tryExport typeof<Double> start world with
                | Some value -> value :?> Double
                | None -> failwith "Invalid argument type for 'start'; expecting a value convertable to Double."
            let song =
                match ScriptingSystem.tryExport typeof<AssetTag<Song>> song world with
                | Some value -> value :?> AssetTag<Song>
                | None -> failwith "Invalid argument type for 'song'; expecting a value convertable to AssetTag`1."
            let result = World.playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong6 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world =
        let oldWorld = world
        try
            let timeToFadeInSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeInSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeInSongMs'; expecting a value convertable to Int32."
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let start =
                match ScriptingSystem.tryExport typeof<Double> start world with
                | Some value -> value :?> Double
                | None -> failwith "Invalid argument type for 'start'; expecting a value convertable to Double."
            let songPackageName =
                match ScriptingSystem.tryExport typeof<String> songPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songPackageName'; expecting a value convertable to String."
            let songAssetName =
                match ScriptingSystem.tryExport typeof<String> songAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songAssetName'; expecting a value convertable to String."
            let result = World.playSong7 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound volume sound world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let sound =
                match ScriptingSystem.tryExport typeof<AssetTag<Sound>> sound world with
                | Some value -> value :?> AssetTag<Sound>
                | None -> failwith "Invalid argument type for 'sound'; expecting a value convertable to AssetTag`1."
            let result = World.playSound volume sound world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound3 volume soundPackageName soundAssetName world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let soundPackageName =
                match ScriptingSystem.tryExport typeof<String> soundPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundPackageName'; expecting a value convertable to String."
            let soundAssetName =
                match ScriptingSystem.tryExport typeof<String> soundAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundAssetName'; expecting a value convertable to String."
            let result = World.playSound4 volume soundPackageName soundAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let fadeOutSong timeToFadeOutSongMs world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let result = World.fadeOutSong timeToFadeOutSongMs world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'fadeOutSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let stopSong world =
        let oldWorld = world
        try
            let result = World.stopSong world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'stopSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadAudioAssets world =
        let oldWorld = world
        try
            let result = World.reloadAudioAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAudioAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadRenderAssets world =
        let oldWorld = world
        try
            let result = World.reloadRenderAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadRenderAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let bodyExists physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.bodyExists physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'bodyExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyContactNormals physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyLinearVelocity physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyLinearVelocity physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormals physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormalOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormalOpt physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormalOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactTangentOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactTangentOpt physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactTangentOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBodyOnGround physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.isBodyOnGround physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBodyOnGround' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBody entity entityId bodyProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let bodyProperties =
                match ScriptingSystem.tryExport typeof<BodyProperties> bodyProperties world with
                | Some value -> value :?> BodyProperties
                | None -> failwith "Invalid argument type for 'bodyProperties'; expecting a value convertable to BodyProperties."
            let result = World.createBody entity entityId bodyProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBodies entity entityId bodiesProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let struct (bodiesProperties, world) =
                match World.evalInternal bodiesProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<BodyProperties> value world with
                            | Some value -> value :?> BodyProperties
                            | None -> failwith "Invalid argument type for 'bodiesProperties'; expecting a value convertable to BodyProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createBodies entity entityId bodiesProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBody physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.destroyBody physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBodies physicsIds world =
        let oldWorld = world
        try
            let struct (physicsIds, world) =
                match World.evalInternal physicsIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<PhysicsId> value world with
                            | Some value -> value :?> PhysicsId
                            | None -> failwith "Invalid argument type for 'physicsIds'; expecting a value convertable to PhysicsId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyBodies physicsIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createJoint entity entityId jointProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let jointProperties =
                match ScriptingSystem.tryExport typeof<JointProperties> jointProperties world with
                | Some value -> value :?> JointProperties
                | None -> failwith "Invalid argument type for 'jointProperties'; expecting a value convertable to JointProperties."
            let result = World.createJoint entity entityId jointProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createJoint' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createJoints entity entityId jointsProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let struct (jointsProperties, world) =
                match World.evalInternal jointsProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<JointProperties> value world with
                            | Some value -> value :?> JointProperties
                            | None -> failwith "Invalid argument type for 'jointsProperties'; expecting a value convertable to JointProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createJoints entity entityId jointsProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createJoints' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyJoint physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.destroyJoint physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyJoint' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyJoints physicsIds world =
        let oldWorld = world
        try
            let struct (physicsIds, world) =
                match World.evalInternal physicsIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<PhysicsId> value world with
                            | Some value -> value :?> PhysicsId
                            | None -> failwith "Invalid argument type for 'physicsIds'; expecting a value convertable to PhysicsId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyJoints physicsIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyJoints' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyEnabled enabled physicsId world =
        let oldWorld = world
        try
            let enabled =
                match ScriptingSystem.tryExport typeof<Boolean> enabled world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'enabled'; expecting a value convertable to Boolean."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyEnabled enabled physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyEnabled' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyPosition position physicsId world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyPosition position physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyPosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyRotation rotation physicsId world =
        let oldWorld = world
        try
            let rotation =
                match ScriptingSystem.tryExport typeof<Single> rotation world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'rotation'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyRotation rotation physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyRotation' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyLinearVelocity linearVelocity physicsId world =
        let oldWorld = world
        try
            let linearVelocity =
                match ScriptingSystem.tryExport typeof<Vector2> linearVelocity world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearVelocity'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyLinearVelocity linearVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyLinearImpulse linearImpulse physicsId world =
        let oldWorld = world
        try
            let linearImpulse =
                match ScriptingSystem.tryExport typeof<Vector2> linearImpulse world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearImpulse'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyLinearImpulse linearImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyLinearImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyAngularVelocity angularVelocity physicsId world =
        let oldWorld = world
        try
            let angularVelocity =
                match ScriptingSystem.tryExport typeof<Single> angularVelocity world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularVelocity'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyAngularVelocity angularVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyAngularVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyAngularImpulse angularImpulse physicsId world =
        let oldWorld = world
        try
            let angularImpulse =
                match ScriptingSystem.tryExport typeof<Single> angularImpulse world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularImpulse'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyAngularImpulse angularImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyAngularImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyForce force physicsId world =
        let oldWorld = world
        try
            let force =
                match ScriptingSystem.tryExport typeof<Vector2> force world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'force'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyForce force physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyForce' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let localizeBodyShape extent bodyShape world =
        let oldWorld = world
        try
            let extent =
                match ScriptingSystem.tryExport typeof<Vector2> extent world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'extent'; expecting a value convertable to Vector2."
            let bodyShape =
                match ScriptingSystem.tryExport typeof<BodyShape> bodyShape world with
                | Some value -> value :?> BodyShape
                | None -> failwith "Invalid argument type for 'bodyShape'; expecting a value convertable to BodyShape."
            let result = World.localizeBodyShape extent bodyShape world
            let value = result
            let value = ScriptingSystem.tryImport typeof<BodyShape> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'localizeBodyShape' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isMouseButtonDown mouseButton world =
        let oldWorld = world
        try
            let mouseButton =
                match ScriptingSystem.tryExport typeof<MouseButton> mouseButton world with
                | Some value -> value :?> MouseButton
                | None -> failwith "Invalid argument type for 'mouseButton'; expecting a value convertable to MouseButton."
            let result = World.isMouseButtonDown mouseButton world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isMouseButtonDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePosition world =
        let oldWorld = world
        try
            let result = World.getMousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyDown key world =
        let oldWorld = world
        try
            let key =
                match ScriptingSystem.tryExport typeof<KeyboardKey> key world with
                | Some value -> value :?> KeyboardKey
                | None -> failwith "Invalid argument type for 'key'; expecting a value convertable to KeyboardKey."
            let result = World.isKeyboardKeyDown key world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let expandContent setScreenSplash content origin owner parent world =
        let oldWorld = world
        try
            let setScreenSplash =
                match ScriptingSystem.tryExport typeof<FSharpFunc<FSharpOption<SplashDescriptor>, FSharpFunc<Screen, FSharpFunc<Screen, FSharpFunc<World, World>>>>> setScreenSplash world with
                | Some value -> value :?> FSharpFunc<FSharpOption<SplashDescriptor>, FSharpFunc<Screen, FSharpFunc<Screen, FSharpFunc<World, World>>>>
                | None -> failwith "Invalid argument type for 'setScreenSplash'; expecting a value convertable to FSharpFunc`2."
            let content =
                match ScriptingSystem.tryExport typeof<SimulantContent> content world with
                | Some value -> value :?> SimulantContent
                | None -> failwith "Invalid argument type for 'content'; expecting a value convertable to SimulantContent."
            let origin =
                match ScriptingSystem.tryExport typeof<ContentOrigin> origin world with
                | Some value -> value :?> ContentOrigin
                | None -> failwith "Invalid argument type for 'origin'; expecting a value convertable to ContentOrigin."
            let struct (owner, world) =
                let context = World.getScriptContext world
                match World.evalInternal owner world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let struct (parent, world) =
                let context = World.getScriptContext world
                match World.evalInternal parent world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.expandContent setScreenSplash content origin owner parent world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'expandContent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyImmediate simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyImmediate simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyImmediate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroy simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroy simulant world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroy' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetParent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getParent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetGrandparent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetGrandparent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetGrandparent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGrandparent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getGrandparent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGrandparent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getChildren simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getChildren simulant world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getChildren' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getExists simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getExists simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities0 world =
        let oldWorld = world
        try
            let result = World.getEntities1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGroups0 world =
        let oldWorld = world
        try
            let result = World.getGroups1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.isSelected simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGameToFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.writeGameToFile filePath world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGameToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGameFromFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.readGameFromFile filePath world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGameFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreens world =
        let oldWorld = world
        try
            let result = World.getScreens world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreens' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setScreenDissolve dissolveDescriptor songOpt screen world =
        let oldWorld = world
        try
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setScreenDissolve dissolveDescriptor songOpt screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setScreenDissolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createScreen dispatcherName nameOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createScreen3 dispatcherName nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveDescriptor =
                match ScriptingSystem.tryExport typeof<DissolveDescriptor> dissolveDescriptor world with
                | Some value -> value :?> DissolveDescriptor
                | None -> failwith "Invalid argument type for 'dissolveDescriptor'; expecting a value convertable to DissolveDescriptor."
            let songOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<SongDescriptor>> songOpt world with
                | Some value -> value :?> FSharpOption<SongDescriptor>
                | None -> failwith "Invalid argument type for 'songOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createDissolveScreen5 dispatcherName nameOpt dissolveDescriptor songOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeScreenToFile filePath screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeScreenToFile filePath screen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeScreenToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readScreenFromFile filePath nameOpt world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.readScreenFromFile filePath nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readScreenFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGroups screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getGroups screen world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGroups' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createGroup dispatcherName nameOpt screen world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createGroup4 dispatcherName nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createGroup' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyGroup group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyGroup group world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroup' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyGroups groups world =
        let oldWorld = world
        try
            let struct (groups, world) =
                let context = World.getScriptContext world
                match World.evalInternal groups world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Group address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyGroups groups world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyGroups' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGroupToFile filePath group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeGroupToFile filePath group world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGroupToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGroupFromFile filePath nameOpt screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readGroupFromFile filePath nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGroupFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryPickEntity position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity position entities world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Entity>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeEntityToFile filePath enity world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (enity, world) =
                let context = World.getScriptContext world
                match World.evalInternal enity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeEntityToFile filePath enity world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeEntityToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities group world =
        let oldWorld = world
        try
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntities group world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntity entity world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyEntity entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntities entities world =
        let oldWorld = world
        try
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyEntities entities world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createEntity dispatcherName nameOpt overlayDescriptor group world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let overlayDescriptor =
                match ScriptingSystem.tryExport typeof<OverlayNameDescriptor> overlayDescriptor world with
                | Some value -> value :?> OverlayNameDescriptor
                | None -> failwith "Invalid argument type for 'overlayDescriptor'; expecting a value convertable to OverlayNameDescriptor."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createEntity5 dispatcherName nameOpt overlayDescriptor group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readEntityFromFile filePath nameOpt group world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readEntityFromFile filePath nameOpt group world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readEntityFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reassignEntity entity nameOpt group world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (group, world) =
                let context = World.getScriptContext world
                match World.evalInternal group world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Group address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.reassignEntity entity nameOpt group world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reassignEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityOverlayNameOpt overlayNameOpt entity world =
        let oldWorld = world
        try
            let overlayNameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> overlayNameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'overlayNameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityOverlayNameOptFromScript overlayNameOpt entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityOverlayNameOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityFacetNames facetNames entity world =
        let oldWorld = world
        try
            let facetNames =
                match ScriptingSystem.tryExport typeof<FSharpSet<String>> facetNames world with
                | Some value -> value :?> FSharpSet<String>
                | None -> failwith "Invalid argument type for 'facetNames'; expecting a value convertable to FSharpSet`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityFacetNamesFromScript facetNames entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityFacetNames' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeCenter world =
        let oldWorld = world
        try
            let result = World.getEyeCenter world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeCenter value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeCenter value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeSize world =
        let oldWorld = world
        try
            let result = World.getEyeSize world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeMargin world =
        let oldWorld = world
        try
            let result = World.getEyeMargin world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeMargin' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeSize value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeSize value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeBounds world =
        let oldWorld = world
        try
            let result = World.getEyeBounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniScreenOpt world =
        let oldWorld = world
        try
            let result = World.getOmniScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setOmniScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniScreen world =
        let oldWorld = world
        try
            let result = World.getOmniScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setOmniScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreenOpt world =
        let oldWorld = world
        try
            let result = World.getSelectedScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let constrainEyeBounds bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.constrainEyeBounds bounds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'constrainEyeBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setSelectedScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreen world =
        let oldWorld = world
        try
            let result = World.getSelectedScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setSelectedScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsRelative world =
        let oldWorld = world
        try
            let result = World.getViewBoundsRelative world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsRelative' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsAbsolute world =
        let oldWorld = world
        try
            let result = World.getViewBoundsAbsolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsAbsolute' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBounds absolute world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let result = World.getViewBounds absolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBoundsInView absolute bounds world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let bounds =
                match ScriptingSystem.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.isBoundsInView absolute bounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInView' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToScreen mousePosition world =
        let oldWorld = world
        try
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToScreen mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToWorld absolute mousePosition world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToWorld absolute mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToWorld' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToEntity absolute entityPosition mousePosition world =
        let oldWorld = world
        try
            let absolute =
                match ScriptingSystem.tryExport typeof<Boolean> absolute world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'absolute'; expecting a value convertable to Boolean."
            let entityPosition =
                match ScriptingSystem.tryExport typeof<Vector2> entityPosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'entityPosition'; expecting a value convertable to Vector2."
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToEntity absolute entityPosition mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let initPropertyAttributes nonPersistent propertyName world =
        let oldWorld = world
        try
            let nonPersistent =
                match ScriptingSystem.tryExport typeof<Boolean> nonPersistent world with
                | Some value -> value :?> Boolean
                | None -> failwith "Invalid argument type for 'nonPersistent'; expecting a value convertable to Boolean."
            let propertyName =
                match ScriptingSystem.tryExport typeof<String> propertyName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'propertyName'; expecting a value convertable to String."
            let result = World.initPropertyAttributesWorld nonPersistent propertyName world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'initPropertyAttributes' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getImperative world =
        let oldWorld = world
        try
            let result = World.getImperative world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getImperative' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getStandAlone world =
        let oldWorld = world
        try
            let result = World.getStandAlone world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getStandAlone' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getCollectionConfig world =
        let oldWorld = world
        try
            let result = World.getCollectionConfig world
            let value = result
            let value = ScriptingSystem.tryImport typeof<TConfig> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getCollectionConfig' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLiveness world =
        let oldWorld = world
        try
            let result = World.getLiveness world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Liveness> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLiveness' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRate world =
        let oldWorld = world
        try
            let result = World.getTickRate world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRateF world =
        let oldWorld = world
        try
            let result = World.getTickRateF world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRateF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setTickRate tickRate world =
        let oldWorld = world
        try
            let tickRate =
                match ScriptingSystem.tryExport typeof<Int64> tickRate world with
                | Some value -> value :?> Int64
                | None -> failwith "Invalid argument type for 'tickRate'; expecting a value convertable to Int64."
            let result = World.setTickRate tickRate world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let resetTickTime world =
        let oldWorld = world
        try
            let result = World.resetTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resetTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let incTickTime world =
        let oldWorld = world
        try
            let result = World.incTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'incTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let decTickTime world =
        let oldWorld = world
        try
            let result = World.decTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'decTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickTime world =
        let oldWorld = world
        try
            let result = World.getTickTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isTicking world =
        let oldWorld = world
        try
            let result = World.isTicking world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isTicking' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getClockDelta world =
        let oldWorld = world
        try
            let result = World.getClockDelta world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getClockDelta' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let exit world =
        let oldWorld = world
        try
            let result = World.exit world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'exit' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadSymbols world =
        let oldWorld = world
        try
            let result = World.reloadSymbols world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadSymbols' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let evalResolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|relation|] -> resolve relation world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalRelateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|address|] -> relate address world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenIdling world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenTransitioning world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSelectScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screenOpt|] -> selectScreenOpt screenOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSelectScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> selectScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> tryTransitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> transitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenSplashBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|splashDataOpt; destination; screen|] -> setScreenSplash splashDataOpt destination screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFile6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile6 dispatcherName nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromGroupFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; dissolveDescriptor; songOpt; groupFilePath|] -> createDissolveScreenFromGroupFile nameOpt dissolveDescriptor songOpt groupFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreen6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; splashDescriptor; destination|] -> createSplashScreen6 dispatcherName nameOpt splashDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; splashDescriptor; destination|] -> createSplashScreen nameOpt splashDescriptor destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadExistingAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadExistingAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryReloadAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryReloadAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCurrentSongPositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCurrentSongPosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterAudioVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSoundVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMasterSongVolume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterAudioVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterAudioVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSoundVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSoundVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetMasterSongVolumeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume|] -> setMasterSongVolume volume world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeInSongMs; timeToFadeOutSongMs; volume; start; song|] -> playSong timeToFadeInSongMs timeToFadeOutSongMs volume start song world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySong6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeInSongMs; timeToFadeOutSongMs; volume; start; songPackageName; songAssetName|] -> playSong6 timeToFadeInSongMs timeToFadeOutSongMs volume start songPackageName songAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySoundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; sound|] -> playSound volume sound world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySound3Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; soundPackageName; soundAssetName|] -> playSound3 volume soundPackageName soundAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalFadeOutSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeOutSongMs|] -> fadeOutSong timeToFadeOutSongMs world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalStopSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> stopSong world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageUseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageUse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageDisuseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageDisuse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadAudioAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadAudioAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintRenderPackageUseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintRenderPackageUse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintRenderPackageDisuseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintRenderPackageDisuse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadRenderAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadRenderAssets world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalBodyExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> bodyExists physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyContactNormals physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyLinearVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactNormals physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactNormalOpt physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactTangentOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactTangentOpt physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBodyOnGroundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> isBodyOnGround physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; bodyProperties|] -> createBody entity entityId bodyProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; bodiesProperties|] -> createBodies entity entityId bodiesProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> destroyBody physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsIds|] -> destroyBodies physicsIds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateJointBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; jointProperties|] -> createJoint entity entityId jointProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateJointsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; jointsProperties|] -> createJoints entity entityId jointsProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyJointBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> destroyJoint physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyJointsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsIds|] -> destroyJoints physicsIds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyEnabledBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|enabled; physicsId|] -> setBodyEnabled enabled physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyPositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; physicsId|] -> setBodyPosition position physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyRotationBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|rotation; physicsId|] -> setBodyRotation rotation physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearVelocity; physicsId|] -> setBodyLinearVelocity linearVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyLinearImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearImpulse; physicsId|] -> applyBodyLinearImpulse linearImpulse physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyAngularVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularVelocity; physicsId|] -> setBodyAngularVelocity angularVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyAngularImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularImpulse; physicsId|] -> applyBodyAngularImpulse angularImpulse physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyForceBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|force; physicsId|] -> applyBodyForce force physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalLocalizeBodyShapeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|extent; bodyShape|] -> localizeBodyShape extent bodyShape world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsMouseButtonDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mouseButton|] -> isMouseButtonDown mouseButton world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardKeyDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|key|] -> isKeyboardKeyDown key world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExpandContentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|setScreenSplash; content; origin; owner; parent|] -> expandContent setScreenSplash content origin owner parent world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyImmediateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroyImmediate simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> destroy simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetGrandparentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetGrandparent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGrandparentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getGrandparent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetChildrenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getChildren simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getExists simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntities0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEntities0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroups0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getGroups0 world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> isSelected simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGameToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> writeGameToFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGameFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> readGameFromFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreensBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreens world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetScreenDissolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dissolveDescriptor; songOpt; screen|] -> setScreenDissolve dissolveDescriptor songOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> destroyScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt|] -> createScreen dispatcherName nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveDescriptor; songOpt|] -> createDissolveScreen dispatcherName nameOpt dissolveDescriptor songOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteScreenToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; screen|] -> writeScreenToFile filePath screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadScreenFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt|] -> readScreenFromFile filePath nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> getGroups screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; screen|] -> createGroup dispatcherName nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> destroyGroup group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyGroupsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|groups|] -> destroyGroups groups world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGroupToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; group|] -> writeGroupToFile filePath group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGroupFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; screen|] -> readGroupFromFile filePath nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryPickEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; entities|] -> tryPickEntity position entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteEntityToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; enity|] -> writeEntityToFile filePath enity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|group|] -> getEntities group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity|] -> destroyEntity entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entities|] -> destroyEntities entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; overlayDescriptor; group|] -> createEntity dispatcherName nameOpt overlayDescriptor group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadEntityFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; group|] -> readEntityFromFile filePath nameOpt group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReassignEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; nameOpt; group|] -> reassignEntity entity nameOpt group world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityOverlayNameOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|overlayNameOpt; entity|] -> trySetEntityOverlayNameOpt overlayNameOpt entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityFacetNamesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|facetNames; entity|] -> trySetEntityFacetNames facetNames entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeCenterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeCenter world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeCenterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeCenter value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeSize world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeMarginBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeMargin world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeSize value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeBoundsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeBounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreenOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreenOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreenOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalConstrainEyeBoundsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds|] -> constrainEyeBounds bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetSelectedScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setSelectedScreenOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setSelectedScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsRelativeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBoundsRelative world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsAbsoluteBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBoundsAbsolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute|] -> getViewBounds absolute world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBoundsInViewBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute; bounds|] -> isBoundsInView absolute bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mousePosition|] -> mouseToScreen mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToWorldBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute; mousePosition|] -> mouseToWorld absolute mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|absolute; entityPosition; mousePosition|] -> mouseToEntity absolute entityPosition mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalInitPropertyAttributesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nonPersistent; propertyName|] -> initPropertyAttributes nonPersistent propertyName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetImperativeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getImperative world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetStandAloneBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getStandAlone world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetCollectionConfigBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getCollectionConfig world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLivenessBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLiveness world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickRate world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickRateFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickRateF world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetTickRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|tickRate|] -> setTickRate tickRate world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalResetTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> resetTickTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIncTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> incTickTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDecTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> decTickTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickTime world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsTickingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isTicking world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetClockDeltaBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getClockDelta world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExitBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> exit world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadSymbolsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadSymbols world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let tryGetBinding fnName =
        match WorldScripting.Bindings.TryGetValue fnName with
        | (true, binding) -> Some binding
        | (false, _) -> None

    let initBindings () =
        let bindings =
            [
             ("resolve", { Fn = evalResolveBinding; Pars = [|"relation"|]; DocOpt = None })
             ("relate", { Fn = evalRelateBinding; Pars = [|"address"|]; DocOpt = None })
             ("tryGetIsSelectedScreenIdling", { Fn = evalTryGetIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("tryGetIsSelectedScreenTransitioning", { Fn = evalTryGetIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenIdling", { Fn = evalIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenTransitioning", { Fn = evalIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("selectScreenOpt", { Fn = evalSelectScreenOptBinding; Pars = [|"screenOpt"|]; DocOpt = None })
             ("selectScreen", { Fn = evalSelectScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("tryTransitionScreen", { Fn = evalTryTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("transitionScreen", { Fn = evalTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("setScreenSplash", { Fn = evalSetScreenSplashBinding; Pars = [|"splashDataOpt"; "destination"; "screen"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile6", { Fn = evalCreateDissolveScreenFromGroupFile6Binding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createDissolveScreenFromGroupFile", { Fn = evalCreateDissolveScreenFromGroupFileBinding; Pars = [|"nameOpt"; "dissolveDescriptor"; "songOpt"; "groupFilePath"|]; DocOpt = None })
             ("createSplashScreen6", { Fn = evalCreateSplashScreen6Binding; Pars = [|"dispatcherName"; "nameOpt"; "splashDescriptor"; "destination"|]; DocOpt = None })
             ("createSplashScreen", { Fn = evalCreateSplashScreenBinding; Pars = [|"nameOpt"; "splashDescriptor"; "destination"|]; DocOpt = None })
             ("reloadExistingAssets", { Fn = evalReloadExistingAssetsBinding; Pars = [||]; DocOpt = None })
             ("tryReloadAssets", { Fn = evalTryReloadAssetsBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongOpt", { Fn = evalGetCurrentSongOptBinding; Pars = [||]; DocOpt = None })
             ("getCurrentSongPosition", { Fn = evalGetCurrentSongPositionBinding; Pars = [||]; DocOpt = None })
             ("getMasterAudioVolume", { Fn = evalGetMasterAudioVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSoundVolume", { Fn = evalGetMasterSoundVolumeBinding; Pars = [||]; DocOpt = None })
             ("getMasterSongVolume", { Fn = evalGetMasterSongVolumeBinding; Pars = [||]; DocOpt = None })
             ("setMasterAudioVolume", { Fn = evalSetMasterAudioVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSoundVolume", { Fn = evalSetMasterSoundVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("setMasterSongVolume", { Fn = evalSetMasterSongVolumeBinding; Pars = [|"volume"|]; DocOpt = None })
             ("playSong", { Fn = evalPlaySongBinding; Pars = [|"timeToFadeInSongMs"; "timeToFadeOutSongMs"; "volume"; "start"; "song"|]; DocOpt = None })
             ("playSong6", { Fn = evalPlaySong6Binding; Pars = [|"timeToFadeInSongMs"; "timeToFadeOutSongMs"; "volume"; "start"; "songPackageName"; "songAssetName"|]; DocOpt = None })
             ("playSound", { Fn = evalPlaySoundBinding; Pars = [|"volume"; "sound"|]; DocOpt = None })
             ("playSound3", { Fn = evalPlaySound3Binding; Pars = [|"volume"; "soundPackageName"; "soundAssetName"|]; DocOpt = None })
             ("fadeOutSong", { Fn = evalFadeOutSongBinding; Pars = [|"timeToFadeOutSongMs"|]; DocOpt = None })
             ("stopSong", { Fn = evalStopSongBinding; Pars = [||]; DocOpt = None })
             ("hintAudioPackageUse", { Fn = evalHintAudioPackageUseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("hintAudioPackageDisuse", { Fn = evalHintAudioPackageDisuseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadAudioAssets", { Fn = evalReloadAudioAssetsBinding; Pars = [||]; DocOpt = None })
             ("hintRenderPackageUse", { Fn = evalHintRenderPackageUseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("hintRenderPackageDisuse", { Fn = evalHintRenderPackageDisuseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadRenderAssets", { Fn = evalReloadRenderAssetsBinding; Pars = [||]; DocOpt = None })
             ("bodyExists", { Fn = evalBodyExistsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyContactNormals", { Fn = evalGetBodyContactNormalsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyLinearVelocity", { Fn = evalGetBodyLinearVelocityBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactNormals", { Fn = evalGetBodyToGroundContactNormalsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactNormalOpt", { Fn = evalGetBodyToGroundContactNormalOptBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactTangentOpt", { Fn = evalGetBodyToGroundContactTangentOptBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("isBodyOnGround", { Fn = evalIsBodyOnGroundBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("createBody", { Fn = evalCreateBodyBinding; Pars = [|"entity"; "entityId"; "bodyProperties"|]; DocOpt = None })
             ("createBodies", { Fn = evalCreateBodiesBinding; Pars = [|"entity"; "entityId"; "bodiesProperties"|]; DocOpt = None })
             ("destroyBody", { Fn = evalDestroyBodyBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("destroyBodies", { Fn = evalDestroyBodiesBinding; Pars = [|"physicsIds"|]; DocOpt = None })
             ("createJoint", { Fn = evalCreateJointBinding; Pars = [|"entity"; "entityId"; "jointProperties"|]; DocOpt = None })
             ("createJoints", { Fn = evalCreateJointsBinding; Pars = [|"entity"; "entityId"; "jointsProperties"|]; DocOpt = None })
             ("destroyJoint", { Fn = evalDestroyJointBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("destroyJoints", { Fn = evalDestroyJointsBinding; Pars = [|"physicsIds"|]; DocOpt = None })
             ("setBodyEnabled", { Fn = evalSetBodyEnabledBinding; Pars = [|"enabled"; "physicsId"|]; DocOpt = None })
             ("setBodyPosition", { Fn = evalSetBodyPositionBinding; Pars = [|"position"; "physicsId"|]; DocOpt = None })
             ("setBodyRotation", { Fn = evalSetBodyRotationBinding; Pars = [|"rotation"; "physicsId"|]; DocOpt = None })
             ("setBodyLinearVelocity", { Fn = evalSetBodyLinearVelocityBinding; Pars = [|"linearVelocity"; "physicsId"|]; DocOpt = None })
             ("applyBodyLinearImpulse", { Fn = evalApplyBodyLinearImpulseBinding; Pars = [|"linearImpulse"; "physicsId"|]; DocOpt = None })
             ("setBodyAngularVelocity", { Fn = evalSetBodyAngularVelocityBinding; Pars = [|"angularVelocity"; "physicsId"|]; DocOpt = None })
             ("applyBodyAngularImpulse", { Fn = evalApplyBodyAngularImpulseBinding; Pars = [|"angularImpulse"; "physicsId"|]; DocOpt = None })
             ("applyBodyForce", { Fn = evalApplyBodyForceBinding; Pars = [|"force"; "physicsId"|]; DocOpt = None })
             ("localizeBodyShape", { Fn = evalLocalizeBodyShapeBinding; Pars = [|"extent"; "bodyShape"|]; DocOpt = None })
             ("isMouseButtonDown", { Fn = evalIsMouseButtonDownBinding; Pars = [|"mouseButton"|]; DocOpt = None })
             ("getMousePosition", { Fn = evalGetMousePositionBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardKeyDown", { Fn = evalIsKeyboardKeyDownBinding; Pars = [|"key"|]; DocOpt = None })
             ("expandContent", { Fn = evalExpandContentBinding; Pars = [|"setScreenSplash"; "content"; "origin"; "owner"; "parent"|]; DocOpt = None })
             ("destroyImmediate", { Fn = evalDestroyImmediateBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("destroy", { Fn = evalDestroyBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetParent", { Fn = evalTryGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getParent", { Fn = evalGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetGrandparent", { Fn = evalTryGetGrandparentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getGrandparent", { Fn = evalGetGrandparentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getChildren", { Fn = evalGetChildrenBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getExists", { Fn = evalGetExistsBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getEntities0", { Fn = evalGetEntities0Binding; Pars = [||]; DocOpt = None })
             ("getGroups0", { Fn = evalGetGroups0Binding; Pars = [||]; DocOpt = None })
             ("isSelected", { Fn = evalIsSelectedBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("writeGameToFile", { Fn = evalWriteGameToFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("readGameFromFile", { Fn = evalReadGameFromFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("getScreens", { Fn = evalGetScreensBinding; Pars = [||]; DocOpt = None })
             ("setScreenDissolve", { Fn = evalSetScreenDissolveBinding; Pars = [|"dissolveDescriptor"; "songOpt"; "screen"|]; DocOpt = None })
             ("destroyScreen", { Fn = evalDestroyScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createScreen", { Fn = evalCreateScreenBinding; Pars = [|"dispatcherName"; "nameOpt"|]; DocOpt = None })
             ("createDissolveScreen", { Fn = evalCreateDissolveScreenBinding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveDescriptor"; "songOpt"|]; DocOpt = None })
             ("writeScreenToFile", { Fn = evalWriteScreenToFileBinding; Pars = [|"filePath"; "screen"|]; DocOpt = None })
             ("readScreenFromFile", { Fn = evalReadScreenFromFileBinding; Pars = [|"filePath"; "nameOpt"|]; DocOpt = None })
             ("getGroups", { Fn = evalGetGroupsBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createGroup", { Fn = evalCreateGroupBinding; Pars = [|"dispatcherName"; "nameOpt"; "screen"|]; DocOpt = None })
             ("destroyGroup", { Fn = evalDestroyGroupBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyGroups", { Fn = evalDestroyGroupsBinding; Pars = [|"groups"|]; DocOpt = None })
             ("writeGroupToFile", { Fn = evalWriteGroupToFileBinding; Pars = [|"filePath"; "group"|]; DocOpt = None })
             ("readGroupFromFile", { Fn = evalReadGroupFromFileBinding; Pars = [|"filePath"; "nameOpt"; "screen"|]; DocOpt = None })
             ("tryPickEntity", { Fn = evalTryPickEntityBinding; Pars = [|"position"; "entities"|]; DocOpt = None })
             ("writeEntityToFile", { Fn = evalWriteEntityToFileBinding; Pars = [|"filePath"; "enity"|]; DocOpt = None })
             ("getEntities", { Fn = evalGetEntitiesBinding; Pars = [|"group"|]; DocOpt = None })
             ("destroyEntity", { Fn = evalDestroyEntityBinding; Pars = [|"entity"|]; DocOpt = None })
             ("destroyEntities", { Fn = evalDestroyEntitiesBinding; Pars = [|"entities"|]; DocOpt = None })
             ("createEntity", { Fn = evalCreateEntityBinding; Pars = [|"dispatcherName"; "nameOpt"; "overlayDescriptor"; "group"|]; DocOpt = None })
             ("readEntityFromFile", { Fn = evalReadEntityFromFileBinding; Pars = [|"filePath"; "nameOpt"; "group"|]; DocOpt = None })
             ("reassignEntity", { Fn = evalReassignEntityBinding; Pars = [|"entity"; "nameOpt"; "group"|]; DocOpt = None })
             ("trySetEntityOverlayNameOpt", { Fn = evalTrySetEntityOverlayNameOptBinding; Pars = [|"overlayNameOpt"; "entity"|]; DocOpt = None })
             ("trySetEntityFacetNames", { Fn = evalTrySetEntityFacetNamesBinding; Pars = [|"facetNames"; "entity"|]; DocOpt = None })
             ("getEyeCenter", { Fn = evalGetEyeCenterBinding; Pars = [||]; DocOpt = None })
             ("setEyeCenter", { Fn = evalSetEyeCenterBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeSize", { Fn = evalGetEyeSizeBinding; Pars = [||]; DocOpt = None })
             ("getEyeMargin", { Fn = evalGetEyeMarginBinding; Pars = [||]; DocOpt = None })
             ("setEyeSize", { Fn = evalSetEyeSizeBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeBounds", { Fn = evalGetEyeBoundsBinding; Pars = [||]; DocOpt = None })
             ("getOmniScreenOpt", { Fn = evalGetOmniScreenOptBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreenOpt", { Fn = evalSetOmniScreenOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getOmniScreen", { Fn = evalGetOmniScreenBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreen", { Fn = evalSetOmniScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getSelectedScreenOpt", { Fn = evalGetSelectedScreenOptBinding; Pars = [||]; DocOpt = None })
             ("constrainEyeBounds", { Fn = evalConstrainEyeBoundsBinding; Pars = [|"bounds"|]; DocOpt = None })
             ("setSelectedScreenOpt", { Fn = evalSetSelectedScreenOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getSelectedScreen", { Fn = evalGetSelectedScreenBinding; Pars = [||]; DocOpt = None })
             ("setSelectedScreen", { Fn = evalSetSelectedScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getViewBoundsRelative", { Fn = evalGetViewBoundsRelativeBinding; Pars = [||]; DocOpt = None })
             ("getViewBoundsAbsolute", { Fn = evalGetViewBoundsAbsoluteBinding; Pars = [||]; DocOpt = None })
             ("getViewBounds", { Fn = evalGetViewBoundsBinding; Pars = [|"absolute"|]; DocOpt = None })
             ("isBoundsInView", { Fn = evalIsBoundsInViewBinding; Pars = [|"absolute"; "bounds"|]; DocOpt = None })
             ("mouseToScreen", { Fn = evalMouseToScreenBinding; Pars = [|"mousePosition"|]; DocOpt = None })
             ("mouseToWorld", { Fn = evalMouseToWorldBinding; Pars = [|"absolute"; "mousePosition"|]; DocOpt = None })
             ("mouseToEntity", { Fn = evalMouseToEntityBinding; Pars = [|"absolute"; "entityPosition"; "mousePosition"|]; DocOpt = None })
             ("initPropertyAttributes", { Fn = evalInitPropertyAttributesBinding; Pars = [|"nonPersistent"; "propertyName"|]; DocOpt = None })
             ("getImperative", { Fn = evalGetImperativeBinding; Pars = [||]; DocOpt = None })
             ("getStandAlone", { Fn = evalGetStandAloneBinding; Pars = [||]; DocOpt = None })
             ("getCollectionConfig", { Fn = evalGetCollectionConfigBinding; Pars = [||]; DocOpt = None })
             ("getLiveness", { Fn = evalGetLivenessBinding; Pars = [||]; DocOpt = None })
             ("getTickRate", { Fn = evalGetTickRateBinding; Pars = [||]; DocOpt = None })
             ("getTickRateF", { Fn = evalGetTickRateFBinding; Pars = [||]; DocOpt = None })
             ("setTickRate", { Fn = evalSetTickRateBinding; Pars = [|"tickRate"|]; DocOpt = None })
             ("resetTickTime", { Fn = evalResetTickTimeBinding; Pars = [||]; DocOpt = None })
             ("incTickTime", { Fn = evalIncTickTimeBinding; Pars = [||]; DocOpt = None })
             ("decTickTime", { Fn = evalDecTickTimeBinding; Pars = [||]; DocOpt = None })
             ("getTickTime", { Fn = evalGetTickTimeBinding; Pars = [||]; DocOpt = None })
             ("isTicking", { Fn = evalIsTickingBinding; Pars = [||]; DocOpt = None })
             ("getClockDelta", { Fn = evalGetClockDeltaBinding; Pars = [||]; DocOpt = None })
             ("exit", { Fn = evalExitBinding; Pars = [||]; DocOpt = None })
             ("tryGetTextureSize", { Fn = evalTryGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSize", { Fn = evalGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("tryGetTextureSizeF", { Fn = evalTryGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSizeF", { Fn = evalGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("reloadSymbols", { Fn = evalReloadSymbolsBinding; Pars = [||]; DocOpt = None })
            ] |>
            dictPlus StringComparer.Ordinal
        WorldScripting.Bindings <- bindings
