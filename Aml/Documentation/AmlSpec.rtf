{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fmodern\fcharset0 CourierNewPSMT;\f2\fmodern\fcharset0 CourierNewPS-BoldMT;
}
{\colortbl;\red255\green255\blue255;\red255\green0\blue0;\red0\green0\blue255;\red0\green128\blue0;
\red0\green77\blue187;}
\vieww18940\viewh16600\viewkind0
\deftab720
\pard\tx4320\pardeftab720

\f0\b\fs28 \cf0 AML - A Modular Language.
\b0  A declarative-first foundation for building declarative languages for .NET. Specialized for different languages through a Language Module (LM). The language is lexically-scoped and strongly dynamically-typed. As much as possible, it is built to enable automated refactoring and reasoning about programs. It features a highly-simplified lisp-style condition system for imperative error handling (called 'interventions').\
\
\ul Text Color Key\
\cf2 \ulnone \
\cf0 Normal text means implemented or mostly so.\cf2 \
Red text means the described feature is not yet implemented.\
\cf3 Blue text demarcates the developer's 'note to self' (feel free to ignore).\cf0 \
\
\ul Syntax Overview\ulnone \
\

\f1 ; blah	Line comment.\
#| blah \cf2 #| blah |#\cf0 |#	Multiline comment \cf2 (nests)\cf0 .\
\
(fn 5)	Function application (AKA, operation).\
[ade tim 10]	Declaration.\
\{a :b "c"\}	Meta expression.\
\
()	Unit.\
#t	True.\
#f	False.\
:thing	Lisp-like keyword.\
:e/fnName	Semantic keyword (here a function name). Needed for automated refactoring to include keyword names.\
\
5(i)	Int (32-bit). Inexact.\
5g	Long (64-bit). Inexact.\
5.0(f)	Float (32-bit). Inexact.\
5.0d	Double (64-bit). Inexact.\cf2 \
5m	Money type. Inexact.\
5n	Native integer. Inexact.\
5b	BigInt (arbitrary size). Exact.\
10/3	Ratio (arbitrary size). Exact.\cf0 \
\
(ref 5)	Build a ref cell with a value of 5.\
(get r)	Get a ref value.\
(set! r 10)	Set a ref value (functions that mutate externally-visible state should end with a bang!)\
(while! expr expr2)	While loop.\
(steps! expr expr2 ... exprN)	Steps (like Lisp progn).\
==	Reference identity equality (or if made into a protocol signature later, simple identity equality).\
/==	Reference identity inequality.\
\
a.b	Selector.\
a::b	Left-associative selector (binds 'tighter' than dot selector).\
\
"string"	String.\
#"verbatim\\string"	Verbatim string.\
\\"c"	Character.\
 \
(list 1 2 3)	List.\
(array 1 2 3)	Array. Indexed as a.0 or (select 0 a). NOTE: arrays are IMMUTABLE. To achieve mutation, build an array of refs.\
(composite (a 1) (b "str") (c \\"c"))	Composite. Indexed as s.a or (select :m/a s).\
(extend c (a 5) (b 6))	Extend a composite with additional members.\
\
(fun (x) pre: expr post: expr body)	Lambda with optional contract predicates.\
\
\cf2 ~x	Shadowed symbol. NOTE: two args created with the same name and by the same frame are considered 'pseudo-shadowing', and cannot be de-shadowed in this way (or any way).\
\cf0 (doc :e/=)	Query an entry\'92s documentation comment.\
(= a b)	Value equality.\
(equal a b)	Structural equality.\
\
$ % & @ \{ \}	Reserved for LM usage.\
\
[usingFile "c:/sim.dol" reload: #t lm: :l/dol]	Evaluate a file, optionally only once per program, optionally with eval by a given LM (here DOL).\
[usingLanguage "c:/..." "MyLM"]	Configure the environment with a LM. Creates only one LM per environment. Additional uses are ignored.\
[usingModule ...] | CapitalizedSymbols	Reserved for module use (if it gets impl'd).\
\
\cf2 [importLanguage ...]	Imports a language for use with the import syntax.\
[:l/dol object ...]	A declaration expression in an imported LM (here DOL). Nested expressions also use the LM. AML environment is shared. [:l ...] simply uses the LM specified by [usingLanguage ...].\
(:l/dol fn ...)	An application expression in an imported LM.\
\{:l/dol on ...\}	A meta expression in an imported LM.\
\cf0 \
[def v 10]	Variable definition.\
[def fn [x] (* x 2)]	Function definition.\
[struct thing [ah ge zi] req: expr]	Structure definition with optional construction contract. Created as (thing x y z) once declared.\
\
(type 5)	Gets the structure that describes a value, structure or function. In this case, a list structure is returned.\
(typeName aThing)	Gets the type name of a structure or function that can be passed to the type function.\
(typeOf :t/list)	Gets the type structure of a type by its name.\
\
?quit	? starts a repl message. Here '?quit' quits the repl. Repl messages take args between spaces, and cannot nest. Args must be literals.\
?redeclaration [on | off]	Turn the ability to redeclare declarations on and off.\cf4 \
\cf2 (| |) [| |] \{| |\} .. with union \cf0 ` , _	Reserved for future use. With would be like ML's \{ v with x = v.y \}. Union would be for a sum type definition (with violations on incomplete matches). Perhaps .. could be useful for some sort of range syntax, or something.\
|	No use (would disallow (||) and similar syntaxes otherwise).\
\pard\pardeftab720

\f0 \cf0 \
\ul Notes\ulnone \
\
Application evaluation can only be specialized to prefixed custom symbols and have additional functions.\
\
Declaration evaluation can be mostly specialized. Declarations never return values as they merely augment the global environment. Must be read at top-level or nested in other declarations or a language specifier in a declaration.\
\
Meta expression evaluation is either entirely specialized or unused.\
\
Macros are not included as the LM is how languages are specified. However, enough syntax 
\i is
\i0  reserved for them. ` is reserved for quote, ' for unquote, and #' for pound-quote (like lisp at-quote).\
\
First class continuations are not to be included.\
\
Like in F#, primitive types do not automatically promote and must be converted manually.\
\
There are 'abstracting' args that automatically wrap an argument's expression in a lambda (thus avoiding dynamic capture) via <|arg|> syntax. Function declarations with labeled args like in Lisp are available via smalltalk-like syntax via 'arg: value'. Also available are variadic args via arg... syntax. Note that currently none of arg specializations can be combined (no labeled abstracting args, no abstracting variadic args, and so on). Also, functions must have their args defined in order of 1) optionally mixed normal args and / or abstracting args, 2) labeled args, then by 3) a single variadic arg. When calling a function, args must be specified in the order they are declared in the function, even if they're labeled.\
\
A structure name is :t/nameOfStructure, a variable name is :e/nameOfVariable, a function name is :e/nameOfFunction, a composite name is :composite, a lambda name is :fun, a primitive name is :nameOfPrimitive, and so on.\
\
For convenience and simplicity, let is always sequential like let* in CL.\
\
\ul Contracts\ulnone \
\
Code contracts are available on lambdas (and thus functions). Contracts use predicates to test whether a function call is valid. Note that there is a build of AML that is \'91optimized\'92 and does not check user-defined contracts at all.\
\
One thing that contracts enforce out of the box is that improper lists cannot be created. If cons receives a non-list as the second parameter, it will propagate a violation.\
\
Contracts signal errors in code through 
\i violations
\i0  \'96 there are no exceptions or the like. Violations can be incurred manually with the 
\i violation
\i0  syntax.\
\
Violations never pop off the stack; instead they propagate automatically for any operation except 'attempt'. This means a built-in 'cond' function will propagate a violation if none of its cases are used. Violations describe the issue that propagated the violation, and may carry additional data.\
\
Any time a built-in operator (other than 'attempt') receives a violation, it will propagate that violation. 
\i This eliminates all unnecessary manual error handling in AML
\i0\b .
\b0  Violations can be handled by the user with the 
\i attempt
\i0  syntax -\
\

\f1 (attempt\
    (causesViolation)\
    (:v/eval "Handle eval violation.")\
    (:v "Handle any violation."))\

\f0 \
Violations can come with data that is accessible in an attempt branch. Here we have violation data that is a composite with a member called 'name' -\
\

\f1 (attempt\
    (causesViolationWithData)\
    (:v/violationWithData data.name))\

\f0 \
If none of the attempt branches match a violation, the violation is simply propagated upward.\
\
To handle a contract failure violation, do like so -\
\

\f1 (attempt\
    (causesContractViolation)\
    (:v/contract (doSomething)))\

\f0 \
Further, custom code can be used to imperatively intevene in the creation of matching violations with the 
\i intervene
\i0  syntax -\
\

\f1 (intervene\
    (causesViolation)\
    (:v/eval problem); Intervene on eval violation, returning the original violation.\
    (:v/reader problem hide: #t); Intervene on a reader violation, returning the original violation, and hide the violation from further intervention.\
    (:v (violation ":v/x" "y" ()))); Intervene on any violation, returning a new violation.\

\f0 \
Intervention sets up expression to be evaluated when the matching violation is created in the call stack. If the matching vioation is created, the result of the expression is returned instead of the newly created violation down in the calling code.\
\
\cf3 TODO: consider implementing a hide syntax like -\

\f2\b (hide :v/x (computeSomething))
\f1\b0 \

\f0 - that is semantically equivalent to -\

\f2\b (intervene (computeSomething) (:v/x problem hide: #t))\

\f0\b0 Attempt branches could even have a hide: arg, too.\cf0 \
\
\ul Protocols\ulnone \
\
Protocols describe a set of values that are compatible with a set of functions. Protocols afford built-in data-directed programming a la SICP. Protocols can 'inherit' from other protocols by using constraints. Protocols may also allow default function implementations in terms of its signatures similar to Haskell's type classes, but this could probably be implemented later.\
\
Lists, arrays, and other collections all have an instantiation under the sequence protocol. A protocol uses a set of functions signatures to implement structure-specific behavior to form an abstraction. For example, (peek (next (list 1 2 3))) yields 2, as does (peek (next (array 1 2 3))), and so on. The concrete map and filter functions operate on the sequence protocol.\
\
Here are the required protocol definitions for sequences -\
\

\f1 [protocol sequence [a]\
    [sig next [a]]\
    [sig peek [a]]\
    [sig isDone [a]]]\

\f0 \
The car and cdr function signatures form the formation protocol, and are instantiated over list and pair structures with an 
\i instance
\i0  out of the box. An instance is how a protocol is instantiated over types of values. Here's a hypothetical implementation. 
\i Note this is no longer how the stdlib does it!
\i0  -\
\

\f1 [protocol formation [a]\
    [sig car [a]]\
    [sig cdr [a]]]\
\
[structure pair [left right]]\
\
[instance formation [[p]] where: [[list p]]\
    [def car [p] p.left]\
    [def cdr [p] p.right]]\
\
[structure list [head tail] where: [[list s.tail]]]\
\
[instance formation [[xs]] where: [[list xs]]\
    [def car [xs] xs.head]\
    [def cdr [xs] xs.tail]]\

\f0 \
That a value supports a protocol is queried by (hasProtocol aProtocol aValue). A value does not have a protocol if does not have an instance of the protocol argument. For protocols, a function signature is defined as its name and number of arguments. Instances must have definitions for all their protocol signatures, or else it's a violation.\
\
You can NOT declare an instance by constraining multiple arguments to a protocol like so -\
\

\f1 [protocol p [v s]\
    [sig f [v s]]]\
\
[instance p [[v s]] where: [[q v s]]\
\pard\tx4320\pardeftab720
\cf0     [def f [v s] expr]]\

\f0 \
Protocol signatures may use only normal args.\
\
\pard\tx4320\pardeftab720
\cf2 \ul \ulc2 Compiler\ulnone \
\
For efficiency, AML has a compiler that is similarly pluggable as the language itself. Just as AML has LM plug-ins, the compiler (AMLC) has LMC plug-ins. Both LMs and LMCs must be written by the end user if he wishes to have a compiling language \cf3 (however there may be a way to have compiled AML code called out to uncompiled LM code, so maybe a missing LMC would not disallow compilation)\cf2 . Initially, the compiler will produce untyped code. Later, as time permits, it will produce some typed code leveraging explicit and inferred constraints. Finally, it will work along-side the symbolic evaluator to strip out contracts where proven enforced at compile-time. Whole program optimization a la SML would also be nice :)\cf0 \
\
\cf2 \ul \ulc2 Editing / Debugging:\ulnone \
\
AML uses Visual Studio as an editor and debugger.\cf0 \
\pard\pardeftab720
\cf0 \
\ul Sample AML Code\ulnone \
\

\f1 [def double [x] (* x 2)]; better than using def and fun\
\
[def sumOfSquares [x y]\
    (let (square (n) (* n n))\
         (x2 (square x))\
         (y2 (square y))\
         (+ x2 y2))]\
\
[def main [args]\
    (sumOfSquares (length args) 23)]\

\f0 \
To see LOTS more good sample AML code, read the Stdlib files :)\
\
\pard\pardeftab720

\b \cf2 DAL - Declarative Attribute Language\cf0 .
\b0  DAL will be the first LM available for AML. DAL is a declarative-first language for implementing interactive systems like UIs and simulations. 
\i Unlike OOP, attributes do not use messages but rather transform through time depending on the state of the world around them.\
\pard\tx4320\pardeftab720

\i0 \cf0 \
\ul Syntax Overview\ulnone \
\

\f1 [attribute ...]	Describes a single attribute.\
[group ...]	Describes a group of attributes.\
\pard\tx4331\pardeftab720
\cf0 [collection ...]	Describes a collection of attributes.\
\pard\tx4320\pardeftab720
\cf0 [repeater ...]	Describes a collection of attributes whose number is parameterized and whose parameters are iteratively specified.\
[source ...]	Describes a single source.\
[transient ...]	Describes a transient source.\
\pard\tx4331\pardeftab720
\cf0 [spawnlet ...]	Describes a spawnlet source.\
\
\{info ...\} |\
\{origin ...\} |\
\{previous\} |\
\{instant ...\} |\
\{instantRandom\} |\
\{first ...\} |\
\{firstRandom\}	Passive attribute calculation expression.\
\
\{base\} |\
\{value ...\} |\
\{yield ...\} |\
\{tally ...\} |\
\{aggregate ...\}	Active attribute calculation expression.\
\
\{get $joe.x\} |	\cf5 Is this the same as \{instant ...\}?\cf0 \
\{set! $joe.x propagate: #t\} |\
\{update! $joe.x inc propagate: #f\}	Attribute get / set / update expressions with optional non-propagation.\
\
$jim.age	Literal address of jim's age attribute (literal addresses are expanded where they are encountered).\
$any.actor.x	Literal address of x attribute of any object with an actor attribute.\
\
%my.x	Relative address of my x (relative addresses are expanded when they are evaluated).\
%parent.x	Relative address of parent's x attribute.\
%desc.x	Relative event descriptor address of x attribute. \
%origin.x	Relative event descriptor address of attribute x.\
\
\{res level1 tree\}	Resource where level1 is the resource package and tree is the resource.\
\pard\tx4331\pardeftab720

\f0 \cf0 \ul \ulc0 \
\pard\pardeftab720
\cf0 \ulc0 Components\
\ulnone \
Through a declarative syntax, 'DAL components' can be registered with DAL. These components expose special built-in attributes, and have the ability to automatically side-effect outward purely by merit of their existence (such as sending drawing instructions to a video buffer) and to be separately affected inward (such as synchronization to the results of a separate physics engine, or updating state as a result of an input device).\
\
Attributes that use a component\'92s special built-in attributes dictate the component\'92s side effects. Sprites, sounds, songs, display windows, and physics bodies may all have built-in attributes that are instantiated at run-time that have special semantics for their respective component.\
\
Outward side-effecting of separate components can be optionally parallelized to run beside one another. Inward side-effecting of separate components cannot be parallelized but can be ordered via some manner of declarative specification.\
\
\ul Hypothetical DAL Code
\b \ulnone \

\b0 \

\f1 [def gravity (v2 0f -9f)]\
\
[group transformation []\
    [[attribute position v2Zero]\
     [attribute scale v2One]]]]\
\
[group actor [translation]; describes an actor as a group of attributes with a translation parameter\
    [[source transform [asGroup transformation [[attribute position (+ (v 1f 1f) translation)]]]]\
     [attribute mass 100f]; attribute mass left at this default doesn't get serialized\
     [attribute actorsCreated \{tally $any.actor.creation\}]]]\
\
[group screen []\
    [[attribute localActor [source actor [(v2 5f 5f)]]]\
     [collection actors\
         [[item $anActor]\
          [item %my.localActor]\
          [item [source anotherLocalActor [asGroup actor [(v2 5f 5f)]]]]]]]]\
\
[newGroup physicalActor []\
    [asGroup actor [(v2 2f -2f)]\
        [[attribute transform\
             [[attribute position\
                  (sum \{base\}\
                       \{aggregate $global.tick (+ state gravity) v2Zero\}\
                       \{aggregate %my.collision (+ state (v2Of (* \{info %desc.force\} 0.5)) v2Zero\})]]]\
                       ; aggregate's body expression gets three implicitly-bound variables; 'value', 'oldValue', and 'state'. Events that come from components have a descriptor value with arbitrary members pertinent to the event's specifics (such as '%desc.normal' for a collision normal).\
\
[source anActor [asGroup physicalActor []]]; declaratively instantiates an actor attribute with name anActor for the life of the program\
\
[source aScreen\
    [asGroup screen\
        [[collection actors\
             [[item [source anotherActor [asGroup actor [(v 3f 4f)]] ...]]]]]]]\
\
[spawnlet anonymous\
    [when \{value $player.shoot\}]; object spawns whenever condition is met\
    [while; object exists only while this condition is met\
        (and (< \{tally $global.tick\} 1000)\
             (not \{value %my.collision\})))]]]\
    [asGroup bullet\
        [[attribute position\
            (+ \{instant $player.transform.position\}\
               (v2 0f \{aggregate $global.tick (+ state bulletSpeed) 0f\}))\
            updateLimit: 1]]; updateLimit limits the number of times an attribute can be updated per tick - useful for breaking update cycles\
\
[source currentScore\
    [asAttribute intValue\
        \{aggregate $any.enemy.health (+ state \{instant %origin.points\}) 0 when: (= (instant %origin.health\} 0)\}]]]\
\
[usingComponent "c:/..." "MyLM"]\
\
[group reactionExamples []\
    creationReaction: (print! "group created!\\n")\
    destructionReaction: (print! "group destroyed!\\n")\
    [[attribute x 0 reaction: (print! "x changed!\\n")]\
     [attribute y 0 reaction: \{update! %my.x inc\}]\
     [attribute z 0 reaction: (print! "z changed!\\n")]]]\

\f0 \
\ul Notes\ulnone \
\
If an attribute is referenced that does not exist, a violation structure is propagated upward. Violations from calculation expressions are ignored, so this does not cause damage to the running program. This eases interactive testing of independent attributes.\
\
Resource expressions are programmatically reasoned about to guide the creation of resource packages. Additionallty, the interpreter can dynamically load or discard resource packages from memory depending on when it should be available for use.\
\
As attributes change through time, they must keep a copy of the value of the type they are defaulted to in their class. This will keep attributes from taking on values that have different types.\
\
It would make tremendous amounts of sense to have versioning on attributes, and to have a syntax for specifying automatic conversion of loaded attributes.\
\
Simulations can be written out perfectly at any time to DAL code. Some limitations may initially apply, such as discarding ongoing event handling contexts. Since there is possibility of imperative code, serialization hooks must be available to allow the user to specify additional serialization handling.\
\
It seems like DAL should be able to be automatically networked for multiple interactive users. Will likely need hooks like serialization.\
\
\pard\pardeftab720

\b \cf2 GOLORP - A Prolog-like language implemented as a LM.
\b0 \cf0 \
\
\pard\pardeftab720
\cf0 \ul \ulc0 Syntax Overview\ulnone \
\
\pard\tx4320\pardeftab720

\f1 \cf0 $v	GOLORP variable name.\
[fact xyz [...]]	Fact about a relationship.\
[rule xyz [...] [...]]	Rule about a relationship.\
\{query ...\}	Unification.\
(glist 1 2 3)	GOLORP list. \
(garray 1 2 3)	GOLORP array.\
(gcomposite (a 1) (b "str") (c \\"c"))	GOLORP composite.\
\pard\pardeftab720

\f0 \cf0 \
\ul Sample GOLORP Code\ulnone \
\

\f1 [fact cat [lion]]\
\
[fact cat [tiger]]\
\
[rule dorothy [$x $y $z]\
  [\{equal $x lion\}\
   \{equal $y tiger\}\
   \{equal $z bear\}]]\
\
[rule twinCats [$x $y]\
  [\{cat $x\}\
   \{cat $y\}]]\
\
\{dorothy lion tiger bear\}\
> (gcomposite truth: yes vars: (gcomposite))\
\
\{dorothy $one $two bear\}\
> (gcomposite truth: yes vars: (gcomposite one: lion two: tiger))\

\f0 \
\pard\pardeftab720

\b \cf2 TSL - Transactional Statement Language.
\b0 \cf0  A transactional statement language such as for shell programming implemented as a LM.\
\pard\tx4320\pardeftab720
\cf0 \
\ul Syntax Overview\ulnone \
\

\f1 [transaction xyz ...]	Defines a transaction block.\
\{doSomething "xyz"\}	Transactional statement (allows side-effects that can be undone).\

\f0 \
\ul Notes\ulnone \
\
Transactional statements always returns :success, :failure, :skipped, or :rollbackAborted.\
\pard\pardeftab720
\cf0 \
\ul Hypothetical TSL Code\ulnone \
\

\f1 [new counter 0]				; create a transactionally mutable variable. It can be rolled back after setting\
\
[transaction makeMyFile [myDir myFile]	; executes statements in order, undoing them if a later one fails.\
  [\{makeDir myDir\}				; skipped if myDir already exists, with roll-back doing nothing\
   \{change counter (inc counter)\}\
   \{changeDir myDir\}\
   \{++ counter\}				; \{++ ...\} is a simpler way to increment a variable than \{change ... (inc ...)\}\
   \{makeFile myFile "Hello, file!"\}	; skipped if myFile already exists and has exactly the "Hello, file!" contents\
   \{++ counter\}]]\
\
\{makeMyFile "c:/myDir" "c:/myFile"\}	; executes the transaction\
\
#| counter will be either 0 or 3 here, and file transactions will have either completed entirely or had no effect, except in the extremely rare case of :rollbackAborted. |#\

\f0 \
\pard\pardeftab720

\b \cf2 DWF \'96 Declarative Windows Forms.
\b0 \cf0  Allows Windows Forms applications to be written in a declarative style, similar to WPF, but should be much simpler if strictly less flexible (which is fine for most uses). Implemented as a component for the DAL LM.\
\pard\pardeftab720
\cf2 \
\pard\pardeftab720

\b \cf2 DRL - Declarative Rendering Language.
\b0 \cf0  Describes how to render DAL attributes of the relevant attributes. It is a component for the DAL LM. Attributes in DRL represent XNA rendering primitives and behaviors. DRL uses existential declaration to \'91skin\'92 matching attributes with visuals. So in pseudo code \'96 \'91where $player exists, red ship with position = player.position\'92.\
\

\b \cf2 DAUDL - Declarative AUDio Language.
\b0 \cf0  Like DRL but for XACT audio.\
\
\pard\pardeftab720

\b \cf0 Alternative Design for AML
\b0  - As AML's design and implementation has progressed, one alternative design has emerged. AML could be designed with an inferred, static type system. This could allow for compiling much faster code with less tooling. An ML-style static type system could do a lot to help generate practical code for LM used in / for real-time systems. If and how such a strict type system would compromise the flexibility of - and increase the workload for - LM authors is unknown... and may not be practical / desirable.\
\
Here also is an alternative syntax where:\
* application is like ML except that newline + indentation (or successive newline) inverts right-associativity\
* declaration is like application except the first expr in the series is post-fixed with colon\
\pard\tx4860\pardeftab720
\cf0 * meta-expression is like declaration except post-fixed with bang\
* parens are used only for grouping and unit, and can be used in any kind of expression\
* redundant grouping parens can be elided\
* operators are infix and work like ML\
* package keys are post-fixed with question mark\
* lambdas use the => syntax, such as 'x => x * 2'\
* uttering function names without application uses hash prefix\
\pard\pardeftab720
\cf0 \
Here are examples -\
\

\f1 def: sum (nums) where? (sequence nums)\
  doc? "Sum a sequences of values."\
  reduce #+ nums\
\
defRec: foldRight (folder state seq) where? ((fun folder) (sequence seq))\
  doc? "Perform a right-associative fold over a sequence. NOTE: this function is not currently tail-recursive."\
  if\
    isDone seq\
    state\
    let\
      elem (peek seq)\
      nextSeq (next seq)\
      nextState (foldRight folder state nextSeq)\
      folder elem nextState\
\
object: anonymous\
  class: bullet\
  while: value! player.shoot && tally! global.tick < 1000 && not (value! my.collision))\
  attributes:\
    position: value! player.transform.position + (v2 0f (aggregate! global.tick (+ state bulletSpeed) 0f))\
    ; and so on...\
\
object: currentScore\
  class: intValue\
  attributes:\
    value:\
      aggregate! any.enemy.health (+ state source.points) 0 when? source.health = 0\

\f0 \
Here\'92s a more java-like syntax which might be better if the type system stays dynamic. The meaning of a bracket, paren, or curly depends on whether it is post-fixed to a symbol. If it is, it\'92s a call, otherwise, it\'92s a grouping. Precedence tightening is not done with parens, but with banana clips, such as (|1 + 2|) * 3.\
\

\f1 defRec[\
  foldRight [folder state seq] where: [[fun folder] [sequence seq]]\
  doc: "Perform a right-associative fold over a sequence. NOTE: this function is not currently tail-recursive."\
  if(isDone(seq)\
     state\
     let((elem peek(seq))\
         (nextSeq next(seq))\
         (nextState foldRight(folder state nextSeq))\
         folder(elem nextState)))]\
\
object[\
  anonymous\
  class[bullet]\
  while[value\{player.shoot\} && tally\{global.tick\} < 1000 && not(value\{my.collision\})]\
  attributes[\
    position[player.transform.position + \{v2 0f (aggregate\{global.tick (+ state bulletSpeed) 0f\})\}]\
    #| and so on... |#]]\
\
object[\
  currentScore\
  class[intValue]\
  attributes[\
    value[\
      aggregate\{any.enemy.health (+ state source.points) 0 when: source.health = 0\}]]]\
}
